package chess.model;

import java.util.List;
import java.util.Stack;

import static java.lang.Math.abs;

/**
 * Represents a game of chess
 */
public class Game {

	private static final String startingPositionFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR";
	public static final int CHECKMATE = 1;
	public static final int REMIS = 2;

	private final Stack<Board> history;

	/**
	 * @return returns the current position
	 */
	public Board getCurrentPosition() {
		return history.peek();
	}

	/**
	 * Start a new game.
	 */
	public Game() {
		this(startingPositionFEN);
	}

	/**
	 * Start a new game.
	 * 
	 * @param startingPosition initial position as fen string
	 */
	public Game(String startingPosition) {
		history = new Stack<>();
		history.push(new Board(startingPosition));
	}

	/**
	 * Attempt to make a move.
	 * 
	 * @param move move which needs to be attempted
	 * @return true if the move was legal and was applied successfully
	 */
	public boolean attemptMove(Move move) {
		Board board = history.peek();
		// directly return false if user tries to move opponent piece
		if (!Piece.isColor(board.getPieceAt(move.getStartSquare()), board.getTurnColor()))
			return false;
		if (!MoveValidator.validateMove(board, move))
			return false;
		history.push(board.makeMove(move));
		return true;
	}

	/**
	 * Pop the last board of the history and set it as current position
	 * 
	 * @return The previous board position or a empty board if history is empty
	 */
	public Board undoMove() {
		if (history.isEmpty())
			return new Board();
		history.pop();
		return history.peek();
	}

	/**
	 * Returns Checkmate or Remis for current player. Beware: If this returns
	 * CHECKMATE the *other color* has won the game!
	 * 
	 * @param board current position
	 * @return 0: NONE, 1: CHECKMATE, 2: REMIS
	 */
	public int checkWinCondition(Board board) {
		MoveGenerator generator = new MoveGenerator(board);
		int check = MoveValidator.checkCheck(board, board.getTurnColor());
		List<Move> possibleMoves = MoveValidator.filter(board, generator.generateMoves());
		if (possibleMoves.isEmpty()) {
			if (check != 0)
				return CHECKMATE;
			return REMIS;
		}
		return 0;
	}

	/**
	 * Returns Checkmate or Remis for current player in game history. Beware: If
	 * this returns CHECKMATE the *other color* has won the game!
	 * 
	 * @return 0: NONE, 1: CHECKMATE, 2: REMIS
	 */
	public int checkWinCondition() {
		return checkWinCondition(getCurrentPosition());
	}

	/**
	 * @return true if king of the current player is in check
	 */
	public boolean checkCheck() {
		Board board = getCurrentPosition();
		return 0 < MoveValidator.checkCheck(board, board.getTurnColor());
	}

	/**
	 * Changes flag field of a Move object (generated by user input) if necessary.
	 * 
	 * @param move the input move providing start and target square
	 */
	public void addFlag(Move move) {
		// do not change already set flag
		if (move.getFlag() != 0)
			return;

		Board board = getCurrentPosition();
		int startSquare = move.getStartSquare();
		int targetSquare = move.getTargetSquare();

		switch (Piece.getType(board.getPieceAt(startSquare))) {
			case Piece.Pawn:
				addFlagPawn(move, board, startSquare, targetSquare);
				break;
			case Piece.King:
				addFlagKing(move, startSquare, targetSquare);
				break;
		}
	}

	private void addFlagPawn(Move move, Board board, int startSquare, int targetSquare) {
		// check two forward
		if (abs(Coordinate.fromIndex(startSquare)[1] - Coordinate.fromIndex(targetSquare)[1]) == 2) {
			move.setFlag(Move.PawnTwoForward);
		} else if (abs(Coordinate.fromIndex(startSquare)[0] - Coordinate.fromIndex(targetSquare)[0]) == 1) {
			// check en passant
			Move enPassantMove = new Move(startSquare, targetSquare, Move.EnPassantCapture);
			MoveGenerator generator = new MoveGenerator(board);
			if (generator.generateMovesStartingAt(startSquare).contains(enPassantMove)) {
				move.setFlag(Move.EnPassantCapture);
			}
		}
		if (Coordinate.isOnUpperBorder(targetSquare) || Coordinate.isOnLowerBorder(targetSquare)) {
			// pawn reached last rank and no flag was set
			// hence promote to Queen by default
			move.setFlag(Move.PromoteToQueen);
		}
	}

	private void addFlagKing(Move move, int startSquare, int targetSquare) {
		int fileDiff = abs(Coordinate.fromIndex(startSquare)[0] - Coordinate.fromIndex(targetSquare)[0]);
		if (fileDiff == 2)
			move.setFlag(Move.Castling);
	}
}
